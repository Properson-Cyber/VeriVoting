from "ecc/babyjubjubParams" import BABYJUBJUB_PARAMS;
import "ecc/edwardsScalarMult" as mul;
import "hashes/sha256/sha256Padded";
import "hashes/sha256/512bit" as hash;
import "hashes/utils/256bitsDirectionHelper" as multiplex;
import "ecc/babyjubjubParams.code" as context;
import "ecc/edwardsScalarMult.code" as mull;
import "ecc/edwardsAdd" as add;

//setting Merkle tree
const u32 DEPTH = 16;
const u32 N =5		;
//Vote algorithm
//bool[256] sk1,bool[256] sk2,bool[256] sk3,
def main(bool[N][256] VoteArra, u8[4] input1, bool[DEPTH] condition1, u32[8] left1, u32[DEPTH][8] path1, bool[N][256] r, field[N][2] pk)->(field[20][2], u32[8], u32[8]) {	
    //set  Merkle Tree   
    u32[8] mut digest = left1;
	// Loop up the tree
    for u32 i in 0..DEPTH {
	    (u32[8], u32[8]) s = (condition1[i] ? path1[i] : left1, condition1[i] ? left1 : path1[i]);
	    digest = hash(s.0, s.1);
        //assert (digest == root1);
    }
    //generate serial number->SN
    u32[8] sn = sha256Padded(input1);
    //predicate condition judgment
	field  mut sum=0;
	field mut vector1 = 0;
	bool mut res_2=true;
       //res=if (a[i]==0||a[i]==1)&&res {true} else {false};
    field mut vot1 = 0;
    field mut vot = 0;
    for u32 i in 0..N{
        for u32 j in 0..256{
            vot1 = if VoteArra[i][j] == false {0} else {1};
            vot = vot + vot1;
        }
        assert(vot==0||vot==1);
    }
	sum = sum + vot;
	res_2=if sum==1 {true} else {false};
    assert (res_2);
    //Encrypt the candidate
    field[20][2] mut Ct = [[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]];
    field[2] G = [16540640123574156134436876038791482806971768689494387082833631921987005038935,
	20819045374670962167435360035096875258406992893633759881276124905556507972311];
    u32 mut k = 0;
    for u32 i in 0..N{
        Ct[k] = mull(r[i],G,context());
        k=k+1;
        Ct[k] = add(mull(r[i],pk[0],context()), mull(VoteArra[0],G,context()),BABYJUBJUB_PARAMS);
        k = k+1;
    }
    return (Ct,sn,digest);
}
